---
title: "Feather River - HSI exploration"
author: "Maddee Rubenson (FlowWest)"
date: "`r Sys.Date()`"
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(tidymodels)


knitr::opts_chunk$set(echo = TRUE)

theme_set(theme_minimal())

```

### Questions/Notes

-   explanation for high fish counts, how are these counted?
-   habitat types are not mutually exclusive, does it make sense to assign weights to types?
-   unique hsi developed for high and low flow channels? habitat type (pool, riffle, run)?
-   `NA`s in `fish_count`, could these be no-fish observations?

**Species**: Chinook, most likely

### TODO:

-   look into how CVPIA habitat docs defined the substrate HSI <https://s3-us-west-2.amazonaws.com/cvpiahabitat-r-package/cvpia-sit-model-inputs/Feather_FERC_IFIM_Phase_2.pdf>
-   continue lit review of HSI methods
-   review cluster analysis and survey analysis techniques to see if they could be applied
-   incorporate additional years of data
-   review and add mini snorkel data

### Limitations:

-   DWR HSC does not include Cover and is outdated <https://s3-us-west-2.amazonaws.com/cvpiahabitat-r-package/cvpia-sit-model-inputs/Feather_FERC_IFIM_Phase_2.pdf>
-   Mostly have data for fish presence, not absence. A lot of NAs in fish_count.

```{r}

# https://github.com/SRJPE/JPE-datasets/blob/main/data-raw/qc-markdowns/seine-snorkel-data/feather-river/feather_snorkel_qc.Rmd
cleaner_snorkel_data <- readRDS('cleaner_snorkel_data.RDS') |> 
  rename(fish_count = count) |> 
  filter(!is.na(fish_count)) |> 
  mutate(section_name = case_when(section_name == "Eye" ~ "Eye Riffle",
                                  section_name == "Vance West" ~ "Vance Riffle",
                                  section_name %in% c("Hatchery Side Ditch") ~ "Hatchery Ditch",
                                  section_name == "Hatchery Side Channel" ~ "Hatchery Riffle", # TODO: check this one
                                  section_name == "Gridley Side Channel" ~ "Gridley Riffle", # TODO: check this one
                                  section_name %in% c("Robinson", "Lower Robinson") ~ "Robinson Riffle",
                                  section_name == "Goose" ~ "Goose Riffle", 
                                  section_name == "Auditorium" ~ "Auditorium Riffle",
                                  section_name %in% c("Matthews", "Mathews", "Mathews Riffle") ~ "Matthews Riffle",
                                  section_name %in% c("G95 Side Channel", "G95 West Side Channel", "G95 Side West", "G95 Side") ~ "G95", 
                                  section_name %in% c("Vance West Riffle", "Vance W Riffle", "Vance East") ~ "Vance Riffle",
                                  section_name == "Moes" ~ "Mo's Ditch",
                                  section_name == "Aleck" ~ "Aleck Riffle",
                                  section_name == "Lower Mcfarland" ~ "McFarland",
                                  section_name %in% c("Bed Rock Riffle", "Bedrock", "Bedrock Park") ~ "Bedrock Park Riffle",
                                  section_name == "Steep" ~ "Steep Riffle",
                                  section_name %in% c("Keister", "Keister Riffle") ~ "Kiester Riffle",
                                  section_name == "Junkyard" ~ "Junkyard Riffle",
                                  section_name == "Gateway" ~ "Gateway Riffle",
                                  section_name == "Trailer Park" ~ "Trailer Park Riffle",
                                  section_name %in% c("Hatchery Ditch And Moes", "Hatchery Ditch Moes Ditch", 
                                                      "Hatchery Side Channel Moes Ditch", 
                                                      "Hatchery Ditch And Moes Ditch", 
                                                      "Hatchery Side Channel And Moes Ditch", 
                                                      "Hatchery Ditch Moes") ~ "Hatchery Ditch and Mo's Ditch", # TODO: check this one since they are separate in the map
                                  section_name %in% c("Hatchery And Moes Side Channels", "Hatchery Side Ch Moes Side Ch", 
                                                      "Hatchery Side Channel And Moes") ~ "Hatchery and Mo's Riffles", # TODO: check on this one 
                                  .default = as.character(section_name))) |> 
  glimpse()

high_flows <- c('Vance Riffle', 'G95', 'Kiester Riffle', 'Goose Riffle', 'Big Riffle', 'McFarland', 'Gridley Riffle', 'Junkyard Riffle')
low_flows <- cleaner_snorkel_data |> filter(!(section_name %in% high_flows)) |> filter(!is.na(section_name)) |> pull(section_name) |> unique()

high_flows
low_flows

cleaner_snorkel_data <- cleaner_snorkel_data |> 
  mutate(channel_flow_type = ifelse(section_name %in% high_flows, "high flow channel", "low flow channel"))

```

```{r}
snorkel_data_dev <- cleaner_snorkel_data |> 
  select(section_name, date, fish_count, substrate, instream_cover, overhead_cover, size_class, est_size) |> 
  mutate(substrate_unique = strsplit(substrate, ""),
         instream_cover_unique = strsplit(instream_cover, ""),
         overhead_cover_unique = strsplit(overhead_cover, "")) |> 
  unnest(substrate_unique) |> 
  unnest(instream_cover_unique) |> 
  unnest(overhead_cover_unique) 
```

### Variable: `substrate`

| SubstrateCode | Substrate                    | Proposed Weight |
|---------------|------------------------------|-----------------|
| 1             | Organic Fines, Mud (0.05 mm) | 1               |
| 2             | Sand (0.05 to 2 mm)          | 1               |
| 3             | Small Gravel (2 to 50 mm)    | 2               |
| 4             | Large Gravel (50 to 150 mm)  | 5               |
| 5             | Cobble (150 to 300 mm)       | 5               |
| 6             | Boulder (\> 300 mm)          | 2               |
| 0             | ?                            | 0               |

### Variable: `instream_cover`

| CoverCode | Cover                                            | Proposed Weight |
|------------------|-------------------------------------|------------------|
| A         | No apparent cover                                | 0               |
| B         | Small instream objects/small-medium woody debris | 2               |
| C         | Large instream objects/large woody debris        | 4               |
| D         | Overhead objects                                 | 4               |
| E         | Submerged aquatic veg/filamentous algae          | 0               |
| F         | Undercut bank                                    | 0               |

### Variable: `overhead_cover`

| CoverCode | Cover                                         | Proposed Weight |
|------------------|-------------------------------------|------------------|
| 0         | No Apparent Cover                             | 0               |
| 1         | Overhanging veg/obj (\< 0.5 m above surface)  | 2               |
| 2         | Overhanging veg/obj (0.5 to 2 m above surface | 4               |
| 3         | Surface turbulence, bubble curtain            | 2               |

### Data Exploration

#### fish count by habitat types

```{r}
snorkel_data_dev |> 
  ggplot() +
  geom_jitter(aes(y = fish_count, x = substrate_unique))

snorkel_data_dev |> 
  ggplot() +
  geom_jitter(aes(y = fish_count, x = instream_cover_unique))

snorkel_data_dev |> 
  ggplot() +
  geom_jitter(aes(y = fish_count, x = overhead_cover_unique))
```

#### Data Completeness

Summarizes how complete the fish count data is by `year`, `section` and `flow type`.

```{r}
# by year
cleaner_snorkel_data |> 
  mutate(year = year(date)) |>
  group_by(year) |> 
  summarise(total_fish_obs = length(fish_count))|> 
  knitr::kable(col.names = c('year', 'total fish observations'))

cleaner_snorkel_data |> 
  group_by(year(date)) |> 
  summarise(total_fish_obs = length(fish_count)) |> 
  rename(year = `year(date)`) |> 
  ggplot() + 
  geom_col(aes(x = as.factor(year), y = total_fish_obs)) +
  xlab("year") + ylab("total fish count observations")

# by section
cleaner_snorkel_data |> 
  group_by(section_name) |> 
  summarise(total_fish_obs = length(fish_count)) |> 
  knitr::kable(col.names = c('section name', 'total fish observations'))

cleaner_snorkel_data |> 
  group_by(section_name) |> 
  summarise(total_fish_obs = length(fish_count)) |> 
  ggplot() + 
  geom_col(aes(x = section_name, y = total_fish_obs)) +
  xlab("section name") + ylab("total fish count observations") + 
  coord_flip()

# by section
cleaner_snorkel_data |> 
  group_by(channel_flow_type) |> 
  summarise(total_fish_obs = length(fish_count)) |> 
  knitr::kable(col.names = c('channel flow type', 'total fish count observations'))

cleaner_snorkel_data |> 
  group_by(channel_flow_type) |> 
  summarise(total_fish_obs = length(fish_count)) |> 
  ggplot() + 
  geom_col(aes(x = channel_flow_type, y = total_fish_obs)) +
  xlab("channel flow type") + ylab("total fish count observations") + 
  coord_flip()

```

#### Fish size

##### Notes

-   size class is mostly `NA`s
-   we do not know what the units are for `est_size` nor what it is describing

| Size Class | Size Range |
|------------|------------|
| I          | 0-50       |
| II         | 51-75      |
| III        | 76-100     |
| IV         | 101-150    |
| V          | 151-300    |
| VI         | 301-499    |
| VII        | 500+       |

```{r}
table(cleaner_snorkel_data$size_class, useNA = "always")
summary(cleaner_snorkel_data$est_size)

```

#### Large Wood

-   assuming `lwd_number` stands for large wood number
-   `28` NAs for large wood
-   mostly `0` values with some values in the 3000 range. The most being `16` observations at a `lwd_number` of `3006`

```{r}
table(as.numeric(cleaner_snorkel_data$lwd_number), useNA = "always")

```

## HSI Dev

### Mark Gard 1998 Process

1.  Determine number of redds with each substrate-size class
2.  Calculate the proportion of redds with each substrate size class
3.  Calculate the HSC value for each substrate size class by dividing the proportion of redds in each substrate class by the proportion of redds with the most frequent substrate class

#### Discussion

-   This process incorporates substrate only - will need to add depth, velocity, and cover\
-   This keeps the substrate types grouped - should we ungroup?
-   Used fish counts instead of redds

```{r}
hsi_dev_markgard_1998 <- cleaner_snorkel_data |> 
  group_by(substrate) |> # note this is grouped by multiple substrate types
  summarise(n_fish = sum(fish_count)) |>  # don't have a value for redds
  mutate(prop_fish_count = n_fish/sum(n_fish)) |> 
  ungroup()

most_freq <- hsi_dev_markgard_1998 |> 
  arrange(desc(n_fish)) |> 
  slice(1) 

hsi_dev_markgard_1998 <- hsi_dev_markgard_1998 |> 
  mutate(hsc = prop_fish_count/most_freq$prop_fish_count)

ggplot(hsi_dev_markgard_1998) +
  geom_col(aes(y = hsc, x = substrate)) +
  coord_flip()

```

## HSI dev using linear regression

#### Assumptions:

-   removed outliers of `fish_count` \> 50
-   substrate and cover variables remain grouped
-   `NA`s on `fish_count` are removed, `NA`s in other variables remain
-   Need to add velocity and depth

```{r message=FALSE, warning=FALSE}
format_snorkel_data <- cleaner_snorkel_data |> 
  select(fish_count, flow, instream_cover, overhead_cover, substrate, temperature, turbidity, hydrology_code, water_depth_m) |> 
  mutate(instream_cover = as.factor(instream_cover),
         overhead_cover = as.factor(overhead_cover),
         hydrology_code = as.factor(hydrology_code),
         substrate = as.factor(substrate),
         fish_presence = as.factor(ifelse(fish_count > 0, "1", "0"))) |> # necessary for a logistic regression 
  filter(fish_count <= 50) |> # removes outliers
  glimpse()

# TODO: velocity + depth

# Define a recipe
rec <- recipe(fish_count ~ instream_cover + overhead_cover + substrate + 
                flow + hydrology_code + turbidity + temperature,   data = format_snorkel_data)  |> 
  step_dummy(all_nominal(), one_hot = TRUE)

# Split the data into training and testing sets
data_split <- initial_split(format_snorkel_data, prop = 0.8, strata = "fish_count")
data_train <- training(data_split)
data_test <- testing(data_split)

# Create a linear regression model
lm_reg <- linear_reg() %>%
  set_engine("lm") %>%
  set_mode("regression")

# Create a workflow
wf <- workflow() %>%
  add_recipe(rec) %>%
  add_model(lm_reg)

# Train the model
wf_fit <- wf |> 
  fit(data_train)

# Make predictions
predictions <- predict(wf_fit, data_test) |> 
  bind_cols(data_test)

wf_fit |> glance()
wf_fit |> tidy()
wf_fit$fit$fit |> dotwhisker::dwplot()

# Normalize predicted probabilities
predictions$normalized_predicted_prob <- (predictions$.pred - min(predictions$.pred, na.rm = TRUE)) / 
                                        (max(predictions$.pred, na.rm = TRUE) - min(predictions$.pred, na.rm = TRUE))

# Create HSI
predictions$HSI <- predictions$normalized_predicted_prob

ggplot(predictions, aes(x = fish_count, y = .pred)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +  # Add a linear regression line
  labs(x = "Actual Fish Abundance", y = "Predicted Fish Abundance") +
  ggtitle("Actual vs. Predicted Fish Abundance")

ggplot(predictions, aes(x = substrate, y = HSI)) +
  geom_boxplot() +
  geom_point() 

ggplot(predictions, aes(x = instream_cover, y = HSI)) +
  geom_boxplot() +
  geom_point() 

ggplot(predictions, aes(x = overhead_cover, y = HSI)) +
  geom_boxplot() +
  geom_point() 

```

## Logistic Regression HSI

```{r eval=FALSE, include=FALSE}
format_snorkel_data <- cleaner_snorkel_data |> 
  select(fish_count, flow, instream_cover, overhead_cover, substrate, temperature, turbidity, hydrology_code, water_depth_m) |> 
  mutate(instream_cover = as.factor(instream_cover),
         overhead_cover = as.factor(overhead_cover),
         hydrology_code = as.factor(hydrology_code),
         substrate = as.factor(substrate),
         fish_presence = as.factor(ifelse(fish_count > 0, "1", "0"))) |> # necessary for a logistic regression 
  glimpse()

# TODO: velocity + depth

# Define a recipe
rec <- recipe(fish_presence ~ instream_cover + overhead_cover + substrate + 
                flow + hydrology_code + turbidity + temperature,   data = format_snorkel_data)  |> 
  step_dummy(all_nominal(), one_hot = TRUE)

# Split the data into training and testing sets
data_split <- initial_split(format_snorkel_data, prop = 0.8, strata = "fish_presence")
data_train <- training(data_split)
data_test <- testing(data_split)

# Create a logistic regression model
log_reg <- logistic_reg() |> 
  set_engine("glm") |> 
  set_mode("classification") |> translate()

# Create a workflow
wf <- workflow()  |> 
  add_recipe(rec) |> 
  add_model(log_reg)

# Train the model
wf_fit <- wf |> 
  fit(data_train)

# Make predictions
predictions <- predict(wf_fit, data_test) |> 
  bind_cols(data_test)

wf_fit |> glance()
wf_fit |> tidy()
# wf_fit$fit$fit |> dotwhisker::dwplot()

# Normalize predicted probabilities
predictions$normalized_predicted_prob <- (predictions$.pred - min(predictions$.pred, na.rm = TRUE)) / 
                                        (max(predictions$.pred, na.rm = TRUE) - min(predictions$.pred, na.rm = TRUE))

# Create HSI
predictions$HSI <- predictions$normalized_predicted_prob

ggplot(predictions, aes(x = fish_count, y = .pred)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +  # Add a linear regression line
  labs(x = "Actual Fish Abundance", y = "Predicted Fish Abundance") +
  ggtitle("Actual vs. Predicted Fish Abundance")

ggplot(predictions, aes(x = substrate, y = HSI)) +
  geom_boxplot() +
  geom_point() 

ggplot(predictions, aes(x = instream_cover, y = HSI)) +
  geom_boxplot() +
  geom_point() 

ggplot(predictions, aes(x = overhead_cover, y = HSI)) +
  geom_boxplot() +
  geom_point() 


```

```{r}

knitr::knit_exit()

```

## HSI Draft Development

### Apply weights to variables and develop HSI

```{r}
substrate_scoring <- c('1' = 1,'2' = 1,'3' = 2, '4' = 5,'5' = 5, '6' = 2,'0' = 0)
instream_cover_scoring <- c('A' = 0, "B" = 2, "C" = 4, "D" = 4, "E" = 0, "F" = 0)
overhead_cover_scoring <- c('0' = 0, '1' = 2,'2' = 4,'3' = 2)

# Define weights for vegetation and substrate
instream_cover_weight <- 0.6
overhead_cover_weight <- 0.3 
substrate_weight <- 0.4

hsi_dev <- snorkel_data_dev |> 
  mutate(normalized_fish_count = fish_count/max(fish_count)) |> 
  mutate(
    instream_cover_score = instream_cover_scoring[instream_cover_unique],
    substrate_score = substrate_scoring[substrate_unique],
    overhead_cover_score = overhead_cover_scoring[overhead_cover_unique],
    hsi = as.numeric((instream_cover_score * instream_cover_weight +
             overhead_cover_score * overhead_cover_weight + 
           substrate_score * substrate_weight) * normalized_fish_count
    )) |> 
  mutate(normalized_hsi = hsi/max(hsi, na.rm = TRUE)) |> 
  glimpse()

```

```{r}
hsi_dev |> 
  ggplot() +
  geom_jitter(aes(y = normalized_hsi, x = substrate_unique, color = fish_count))

hsi_dev |> 
  ggplot() +
  geom_jitter(aes(y = normalized_hsi, x = instream_cover_unique, color = fish_count))

hsi_dev |> 
  ggplot() +
  geom_jitter(aes(y = normalized_hsi, x = overhead_cover_unique, color = fish_count))


hsi_dev |> 
  ggplot() +
  geom_histogram(aes(x = normalized_hsi))

hsi_dev |> 
  ggplot() +
  geom_point(aes(x = fish_count, y = normalized_hsi, color = instream_cover_unique))

hsi_dev |>  
  ggplot() +
  geom_point(aes(x = fish_count, y = normalized_hsi)) +
  facet_wrap(~section_name)
```

### Create a single HSI per fish count

```{r}

hsi_grouped <- hsi_dev |> 
  group_by(fish_count) |> 
  summarise(hsi_val_mean = mean(normalized_hsi, na.rm = TRUE),
            hsi_val_median = median(normalized_hsi, na.rm = TRUE))

hsi_grouped |> 
  ggplot() + 
  geom_point(aes(x = fish_count, y = hsi_val_mean)) + 
  geom_smooth(aes(x = fish_count, y = hsi_val_mean))

hsi_grouped |> 
  ggplot() + 
  geom_point(aes(x = fish_count, y = hsi_val_median)) + 
  geom_smooth(aes(x = fish_count, y = hsi_val_median))

```
