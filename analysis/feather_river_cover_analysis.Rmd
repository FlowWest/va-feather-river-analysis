---
title: "Feather River - Mini Snorkel Data Modeling and Analysis"
author: "Maddee Wiggins (FlowWest)"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
library(tidyverse)
library(sjPlot)
library(pROC)
library(glmmTMB)
library(sf)
library(leaflet)
library(scales)

knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)

theme_set(
  theme_minimal() +
    theme(
      plot.title = element_text(size = 11, face = "bold"),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14)
    )
)


custom_colors <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

colors_full <-  c("#9A8822", "#F5CDB4", "#F8AFA8", "#FDDDA0", "#74A089", #Royal 2
                  "#899DA4", "#C93312", "#DC863B", # royal 1 (- 3)
                  "#F1BB7B", "#FD6467", "#5B1A18", "#D67236",# Grand Budapest 1 (-4)
                  "#D8B70A", "#02401B", "#A2A475", # Cavalcanti 1
                  "#E6A0C4", "#C6CDF7", "#D8A499", "#7294D4", #Grand Budapest 2
                  "#9986A5", "#EAD3BF", "#AA9486", "#B6854D", "#798E87", # Isle of dogs 2 altered slightly
                  "#F3DF6C", "#CEAB07", "#D5D5D3", "#24281A", # Moonriese 1, 
                  "#798E87", "#C27D38", "#CCC591", "#29211F", # moonrise 2
                  "#85D4E3", "#F4B5BD", "#9C964A", "#CDC08C", "#FAD77B" ) # moonrise 3 

options(scipen=999)

```

## Objective

Develop a model that reflects the significance of cover, substrate,
depth, and velocity on fish presence and absence.

## Analysis Overview

Model was developed using [Feather River Mini Snorkel
Data](https://github.com/Healthy-Rivers-and-Landscapes-Science/feather-river/tree/main/edi-mini-snorkel).
The dataset consists of numeric fish count observations that can also be
expressed as a binary presence–absence response. Because the counts were
highly zero-inflated (i.e., many observations with no fish detected), we
initially evaluated a hurdle modeling approach following the framework
described in Gard (2024, in review). Hurdle models are well suited for
datasets dominated by absences, as they separately model the processes
governing occurrence and abundance. In our case, the hurdle model
provided reasonable performance for the presence–absence (zero)
component but performed poorly for the count component, indicating that
fish abundance could not be reliably predicted from the available
covariates. Given this limitation, we shifted our focus to occurrence
modeling using logistic regression. The strongest overall performance
was obtained using a mixed-effects logistic regression that included a
random intercept for transect sites nested within channel location
(high-flow and low-flow channels), allowing us to account for spatial
structure and repeated sampling within sites.

```{r}
source(here::here("data-raw", "pull_from_edi.R"))

mini_snorkel_raw <- mini_fish_raw |> 
  left_join(mini_locations_raw |> distinct()) |> 
  mutate(count = ifelse(is.na(count), 0, count),
         fish_presence = as.factor(ifelse(count < 1, "0", "1")),
         month = month(date)) |> 
  glimpse()

```

## Review Data

#### Outliers

`count` outliers exist, in the high flow and the low flow channel,
however their removal did not impact the model results so they were kept
in the dataset.

```{r eval=FALSE, include=FALSE}
# Keeping this figure out of analysis but keeping for future
mini_snorkel_raw |>
  ggplot() +
  geom_boxplot(aes(x = channel_location, y = count)) +
  geom_jitter(aes(x = channel_location, y = count), alpha = 0.5) +
  ggtitle("Outliers of fish count")
```

We thought that by removing values greater than 250 this would limit
overdispersion in the count model, however, it did not.

```{r echo=FALSE, message=FALSE, warning=FALSE}
mini_snorkel_raw |> 
  filter(count > 0) |> 
  ggplot() + 
  geom_histogram(aes(count, fill = channel_location), binwidth = 50) + 
  scale_fill_manual(values = custom_colors) + 
  ylab("fish count") +
  ggtitle('Figure 1. Histogram of fish count in the high and low flow channels') +facet_grid(~channel_location)

mini_snorkel_model_ready <- mini_snorkel_raw
```

### High Flow vs. Low Flow Channel

Table 1 and figure 2 explore whether fish presence was impacted by the
high or low flow channels. Overall there are similar numbers of fish
present in the high flow channel compared to the low flow channel (table
1). There are more fish present in the high flow channel in March but
they move quickly downstream. Fish remain in the low flow channel for
much longer time (figure 2).

do we have the same amount of sampling plots in the high flow vs. low
flow?

```{r echo=FALSE, message=FALSE, warning=FALSE}

# looking at overall count data between the low flow/high flow channels
mini_snorkel_model_ready |> 
  group_by(channel_location) |> 
  tally(count) |> 
  knitr::kable(caption = "Table 1. Total count of fish between high flow and low flow channels")

mini_snorkel_model_ready |> 
  group_by(channel_location) |> 
  summarize(n_sites = length(unique(location))) |> 
  knitr::kable(caption = "Table 2. Number of sampling sites in the high flow and low flow channels")

# This figure shows how there are more fish present in the high flow channel 
# for less time. The fish stick around for much longer in the low flow channel. 
mini_snorkel_model_ready |> 
  group_by(channel_location, month = lubridate::month(date)) |> 
  tally(count) |> 
  ggplot() + 
  geom_col(aes(x = as.factor(month), y = n, fill = channel_location), position = "dodge") + 
  ylab("fish count") +
  xlab("month") +
  ggtitle('Figure 2. Fish presence as a function of month and high flow/low flow channel') + 
  scale_fill_manual(values = custom_colors)

```

### Redd Location Exploration

**Process**

-   Source Feather River redd data from EDI
-   Remove locations that have zero redds
-   From Mini Snorkel data, extract location, channel type, channel
    location (High Flow vs. Low Flow), and number of fish counted

```{r}
# remove zero redds
redd_data_with_redds <- redd_data |> 
  filter(number_redds > 0)
```

**Redd data over time**

This visual represents the number of redds over time at each location.
It helps provide context on which sites generally have redds and if they
have redds consistently over time. The Mini Snorkel data was collected
from `r min(mini_snorkel_raw$date)` to `r max(mini_snorkel_raw$date)` so
it does not align with the redd data.

```{r}
redd_data_with_redds |> 
  ggplot(aes(x = lubridate::year(date), y = location, fill = number_redds)) +
  geom_tile(color = "white",  linewidth = 0.5) + 
  xlab("Year")
```

Combine redd data with mini snorkel to see if redds are a spatial
indicator or spawning potential/habitat quality.

```{r}
redd_data_by_location <- redd_data |> 
  group_by(longitude, latitude, location) |> 
  summarise(n_redds = sum(number_redds),
            n_fish_on_redds = sum(number_salmon)) |>  # TODO: double check this variable is interpreted correctly. On redd or near redd?
  mutate(n_fish_on_redds = replace_na(n_fish_on_redds, 0)) |> 
  filter(!is.na(longitude)) |> 
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

redd_data_by_location |> 
  ggplot(aes(x = location, y = n_redds)) +
  geom_col() +
  coord_flip()

mini_sf <- mini_snorkel_model_ready |> 
  filter(!is.na(longitude)) |> 
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326) |> 
  glimpse()
```

Find the nearest transect location from the Mini Snorkel data to each
redd

TODO: QC this

```{r}
dist_to_nearest <- st_distance(
  redd_data_by_location,
  mini_sf[st_nearest_feature(redd_data_by_location, mini_sf), ],
  by_element = TRUE
)

redd_near <- redd_data_by_location |>
  mutate(dist_to_nearest = as.numeric(dist_to_nearest)) |> 
  filter(dist_to_nearest <= 50)

redd_near_with_snorkel <- st_join(
  redd_near |> select(-location),
  mini_sf,
  join = st_nearest_feature
)

redd_data_by_location |>
  mutate(dist_to_nearest = as.numeric(dist_to_nearest)) |> 
  ggplot(aes(x = dist_to_nearest)) +
  geom_histogram(binwidth = 5, boundary = 0) +
  geom_vline(xintercept = 50, linetype = 2, color = "red") +
  labs(
    title = "QC: distribution of nearest-neighbor distances"
  ) +
  theme_minimal(base_size = 13)

redd_summary <- redd_near_with_snorkel |>
  st_drop_geometry() |>
  group_by(location) |>
  summarise(
    redd_total = sum(n_redds),                    
    redd_presence = as.integer(redd_total > 0)
  )
```

```{r}

locations_sf <- sf::st_as_sf(mini_locations_raw |> 
                               distinct(location_table_id, date, channel_location, .keep_all = T) |> 
                               na.omit(), 
                             coords = c('longitude', 'latitude')) |> 
  select(location_table_id, location, channel_type, date) |> 
  mutate(location_table_id = paste0(date, " (location id: ", location_table_id, ")")) |> 
  mutate(color = colors_full[match(location, location)]) |> 
  group_by(location) |> 
  slice(1) |> # This is a bit of a workaround since there are multiple lat/longs for reach location that are near eachother. Since this is just for a visual, I think it's fine. 
  ungroup()

redd_summary_sf <- redd_summary |> 
  left_join(locations_sf) |> 
  select(location, redd_presence, redd_total, geometry) |> 
  distinct() |> 
  sf::st_as_sf(sf_column_name = "geometry", crs = 4326)



leaflet() |>
  addProviderTiles(providers$Esri.WorldImagery, group = "Aerial Imagery") |>
  addProviderTiles(providers$OpenStreetMap, group = "Street Map") |>
   addCircleMarkers(data = locations_sf, 
                     layerId = ~location, 
                     color = ~color,
                     radius = 6,
                     fill = TRUE,
                     fillOpacity = 0.2,
                     opacity = 0.6,
                     popup = paste0("Location Name: ", locations_sf$location,
                                    "<br>",
                                    "Channel Type: ", locations_sf$channel_type)) |> 
  addCircleMarkers(data = redd_summary_sf, 
                   color = "darkred",
                   radius = ~rescale(redd_total, to = c(3, 20)),
                   fill = TRUE,
                   fillOpacity = 1,
                   opacity = 1, 
                   popup = paste0("Location Name: ", redd_summary_sf$location,
                                    "<br>",
                                    "N Redds: ", redd_summary_sf$redd_total)) |> 
   
  addLayersControl(
    baseGroups = c("Aerial Imagery", "Street Map"),
    position = "topleft",
    options = layersControlOptions(collapsed = FALSE)
  ) |> 
  addLegend(colors = "darkred", labels = "Redd Locations") 

```

### Variables of Interest

The variables of interest include cover, substrate, velocity and depth
variables known to be important for salmon rearing habitat. We are also
including the number or redds nearby, when applicable.

-   Velocity - numeric
-   Depth - numeric
-   Number or Redds - numeric

Substrate and cover variables are measured as percentages which can also
be modeled as binary by establishing a threshold percentage. Overhanging
vegetation was measured at 1/2 meter overhead and more than 1/2 meter
overhead. These categories were combined for simplicity and for
comparison with other studies, such as those by Mark Gard.

-   Undercut bank
-   Aquatic vegetation
-   Overhanging vegetation
-   Small woody cover
-   Large woody cover
-   Boulder substrate
-   Cobble substrate

Data was collected between March through August, however, outmigration
affects fish presence later in the season. We do not include month as it
is a strong predictor of fish presence. The analysis could be limited to
focus on the month with most observations (March), though including all
months also makes sense if seeking to determine variables that are
stable throughout time.

The conditions in the HFC and LFC are quite different and some initial
exploration was done to explore this by creating separate models for the
LFC and HFC. The results did not differ significantly. Spatial nuances
may best be explored at the site level.

## Hurdle Model Approach

### Hurdle Models and Interpretation

A hurdle model was used in Gard 2024 (in-review) to test for the effects
of cover and habitat type on the total abundance of Chinook salmon at
both site and cell level. Here we explore the use oif a hurdle model to
help understand the influence of velocity, depth, and cover on fish
count and presence/absence.

**Hurdle Models**

Hurdle models are used when count data has an excess of zeros. These
models can be understood as a mixture of two subset of populations. In
one subset, we have a usual count model that may or may not generate
zero, and the other subset only produce zero count.

A hurdle model models excess zeroes separately from the rest of the
data. The zero counts are modeled as a binary response variable and the
positive counts are modeled using poisson distribution.

*Interpreting a Hurdle Model*

The binary part of the model helps identify factors that influence the
presence/absence of fish. The coefficients of the zero part of the
hurdle model represent the odds ratio of observing at least one fish.

The count part of the model estimate the effects of predictor variables
on the count outcome, excluding all zero counts. Coefficients of counts
represent rate ratios of one or more fish observed.

The Incidence Result Ratio (IRR) in the count part of the model (count
\> 0) represent the multiplicative effect of a one-unit change in a
predictor variable on the expected count of non-zero observations,
assuming all other variables are held constant. For example, if the IRR
for a predictor is 1.2, it means that a one-unit increase in that
predictor is associated with a 20% increase in the expected count of
non-zero observations, assuming all other variables remain constant. For
the binary part of the model - if the coefficient for a predictor in the
binary part of the hurdle model is 0.5, it means that a one-unit
increase in the predictor is associated with a 50% increase in the odds
of having a zero count versus a positive count, assuming all other
variables are held constant.

### Build Model

All cover variables were converted to presence/absence using a threshold
of 20%. The following is the data structure of the model input data.

```{r echo=FALSE, message=FALSE, warning=FALSE}
percent_threshold <- 20

# use a hurdle model (Gard 2024); 
# pre-processing - all numeric values must be rounded to whole numbers
hurdle_data <- mini_snorkel_model_ready |>
  select(count, location, channel_location, depth, velocity, contains("inchannel"), contains("overhead"), "percent_cobble_substrate", "percent_boulder_substrate", "percent_undercut_bank", month, fl_mm) |>
  # create new cover variables, based off Gard 2023
  mutate(small_woody = percent_small_woody_cover_inchannel,
         large_woody = percent_large_woody_cover_inchannel,
         boulder_substrate = percent_boulder_substrate,
         cobble_substrate = percent_cobble_substrate, 
         undercut_bank = percent_undercut_bank, 
         aquatic_veg = percent_submerged_aquatic_veg_inchannel, 
         overhanging_veg = percent_cover_half_meter_overhead + percent_cover_more_than_half_meter_overhead) |>
  # transform to presence/absence based on a defined threshold
  mutate(cobble_substrate = ifelse(percent_cobble_substrate >= percent_threshold, 1, 0 ),
         boulder_substrate = ifelse(percent_boulder_substrate >= percent_threshold, 1, 0 ),
         small_woody = ifelse(small_woody >= percent_threshold, 1, 0 ),
         large_woody = ifelse(large_woody >= percent_threshold, 1, 0 ),
         aquatic_veg = ifelse(aquatic_veg >= percent_threshold, 1, 0),
         undercut_bank = ifelse(undercut_bank >= percent_threshold, 1, 0),
         no_cover_overhead = ifelse(percent_no_cover_overhead >= percent_threshold, 1, 0),
         overhanging_veg = ifelse(overhanging_veg >= percent_threshold, 1, 0)) |>
  #remove no cover variables (no cover overhead, no cover in channel)
  select(-contains("no_cover")) |> 
  distinct() |> 
  mutate(fl_mm = ifelse(is.na(fl_mm), 0, fl_mm)) |> 
  na.omit() |> 
  select(-fl_mm) |> 
  left_join(redd_summary) |> 
  mutate(
    redd_total = replace_na(redd_total, 0),
    redd_presence = replace_na(redd_presence, 0)
  ) |> 
  glimpse()

```

### Results summary

```{r}
hurdle_model <- pscl::hurdle(count ~ small_woody + depth + velocity + large_woody + aquatic_veg + overhanging_veg + cobble_substrate + boulder_substrate + undercut_bank + redd_total + redd_presence, data = hurdle_data, dist = "negbin") 
# Negative Binomial Distribution: The Negative Binomial distribution is more flexible than the Poisson distribution and is used when the variance of the counts is greater than the mean, which is known as overdispersion. The Negative Binomial model allows for the variance to be larger than the mean, which is common in count data where there is extra variability beyond what is expected from a Poisson distribution.

# zero inflated models are capable of dealing with excess zero counts
# NOTE: Chose to not use a zero inflated model because it operates under the assumption that excess zeros are generated by a separate process from the count values. 
# zeroinf_model <- pscl::zeroinfl(count ~ ., data = hurdle_data) # , zero.dist = "binomial", dist = "negbin"

best_model_hurdle <- MASS::stepAIC(hurdle_model)
summary(best_model_hurdle)
```

```{r}
plot_model(best_model_hurdle, title = "Figure 3. Hurdle Model Results Using Binary Presence/Absence for Cover and Substrate",  wrap.title = 50) + 
  scale_color_manual(values = custom_colors[5:6])

```

```{r include=FALSE}
s <- summary(best_model_hurdle)

# Extract components
count_coef <- as.data.frame(s$coefficients$count) |>
  tibble::rownames_to_column("term") |>
  rename(Estimate = Estimate,
         Std.Error = `Std. Error`,
         z = `z value`,
         p.value = `Pr(>|z|)`) |>
  mutate(
    effect_type = "Abundance (Count Multiplier)",
    exp_effect = exp(Estimate)
  )

zero_coef <- as.data.frame(s$coefficients$zero) |>
  tibble::rownames_to_column("term") |>
  rename(Estimate = Estimate,
         Std.Error = `Std. Error`,
         z = `z value`,
         p.value = `Pr(>|z|)`) |>
  mutate(
    effect_type = "Presence (Odds Ratio)",
    exp_effect = exp(Estimate)
  )

# Combine & clean
effect_table <- bind_rows(zero_coef, count_coef) |>
  mutate(
    term = recode(term,
                  "(Intercept)" = "Intercept",
                  small_woody = "Small woody debris",
                  large_woody = "Large woody debris",
                  overhanging_veg = "Overhanging vegetation",
                  aquatic_veg = "Aquatic vegetation",
                  cobble_substrate = "Cobble substrate",
                  boulder_substrate = "Boulder substrate",
                  undercut_bank = "Undercut bank",
                  depth = "Depth",
                  velocity = "Velocity"
    ),
    exp_effect = round(exp_effect, 2),
    Estimate   = round(Estimate, 3),
    Std.Error  = round(Std.Error, 3),
    p.value    = signif(p.value, 3)
  ) |>
  rename(
    Variable = term,
    `Effect type` = effect_type,
    `Exp(effect)` = exp_effect
  )

knitr::kable(effect_table, align = "lcccc")

```

### Model Performance

#### Evaluate the presence / absence component (classification)

```{r}
pred_presence <- predict(
  best_model_hurdle,
  type = "response",
  which = "zero"
)
obs_presence <- as.integer(hurdle_data$count > 0)

roc_presence <- roc(obs_presence, pred_presence)
auc(roc_presence)

# Interpretation:
# AUC = 0.5 → no better than random
# 0.7–0.8 → acceptable
# 0.8–0.9 → good
# >0.9 → excellent

pred_class <- ifelse(pred_presence > 0.5, 1, 0)
table(Predicted = pred_class, Observed = obs_presence)

```

An AUC of `r auc(roc_presence)` detects from predictive capabilities in
dectecting presence/absence using habitat variables but it is weak.
However the confusion matrix implies poor predictability of presence
which is likely due to the dataset being so heavily skewed towards
absence. Because non-zero counts were low and weakly explained,
abundance predictions were unreliable.

#### Evaluate the count component (abundance, conditional on presence)

Only evaluate sites where count \> 0.

```{r}
present_idx <- hurdle_data$count > 0

pred_count <- predict(
  best_model_hurdle,
  type = "response",
  which = "count"
)[present_idx]

obs_count <- hurdle_data$count[present_idx]

rmse  <- sqrt(mean((obs_count - pred_count)^2))
mae   <- mean(abs(obs_count - pred_count))
r2    <- cor(obs_count, pred_count)^2
c(rmse = rmse, mae = mae, r2 = r2)

# Interpretation:
# Lower RMSE/MAE = better fit
# Higher R² = stronger correspondence

plot(pred_count, obs_count)
abline(0,1,col="red")

```

The count component of the hurdle model performed very poorly (RMSE =
150.6, MAE = 43.0, pseudo-R² = 0.02), indicating that the model
explained virtually none of the variation in non-zero fish counts.

### Hurdle Model Discussion

The hurdle model is performing okay (AUC of `r auc(roc_presence)`) for
presence/absence but there is a poor predictive skill for the count
variable likely due to many counts being low but with high variability.
Because of this, we chose to model habitat associations for fish
occurrence using a logistic model, which is most consistent with the
information content of the data.

```{r eval=FALSE, include=FALSE}
hist(hurdle_data$count[hurdle_data$count>0])
```

## Logistic Regression Approach

```{r}
log_reg_data <- hurdle_data |> 
  mutate(presence = as.integer(count > 0))
```

### Build Logistic Regression Model

```{r}
glm_presence <- glm(
  presence ~ small_woody + depth + velocity + large_woody +
    aquatic_veg + overhanging_veg + cobble_substrate +
    boulder_substrate + undercut_bank + redd_total + redd_presence,
  data = log_reg_data,
  family = binomial(link = "logit")
)

summary(glm_presence)

```

<!-- **Odds Ratio** -->

```{r eval=FALSE, include=FALSE}
presence_table <- broom::tidy(glm_presence, conf.int = TRUE) |>
  mutate(
    odds_ratio = exp(estimate),
    or_low = exp(conf.low),
    or_high = exp(conf.high)
  ) |>
  transmute(
    term,
    estimate = round(estimate, 3),
    `Std.Error` = round(std.error, 3),
    `Odds ratio` = round(odds_ratio, 2),
    `95% CI` = sprintf("[%.2f, %.2f]", or_low, or_high),
    `p` = signif(p.value, 3)
  )

knitr::kable(presence_table)

```

### Performance

```{r}

pred_prob <- predict(glm_presence, type = "response")
obs <- log_reg_data$presence

roc_glm <- roc(obs, pred_prob)
auc(roc_glm)   # slightly better performing 

# pred_class <- ifelse(pred_presence > 0.5, 1, 0)
# table(Predicted = pred_class, Observed = obs_presence)
```

AUC of `r auc(roc_glm)` means The habitat variables explain some
presence–absence structure, but there is still a lot of overlap/noise in
the data.

```{r echo=FALSE}
# confusion matrix 
pred_class <- ifelse(pred_prob > 0.5, 1, 0)
table(Predicted = pred_class, Observed = obs)
```

**Confusion Matrix**

| Term                 | Meaning                              |
|----------------------|--------------------------------------|
| True Negatives (TN)  | correctly predicted absence          |
| False Negatives (FN) | missed real presences                |
| False Positives (FP) | predicted presence but none observed |
| True Positives (TP)  | correctly predicted presence         |

### Add Random Effect

```{r}

glmm_presence <- glmmTMB(
  presence ~ small_woody + depth + velocity + large_woody +
    aquatic_veg + overhanging_veg + cobble_substrate +
    boulder_substrate + undercut_bank + redd_total + redd_presence + 
    (1 | channel_location/location),                     
  data = log_reg_data,
  family = binomial(link = "logit")
)

summary(glmm_presence)


```

<!-- **Odds ratio** -->

```{r eval=FALSE, include=FALSE}
or_table <- broom.mixed::tidy(glmm_presence, effects = "fixed", conf.int = TRUE) |>
  mutate(
    odds_ratio = exp(estimate),
    or_low = exp(conf.low),
    or_high = exp(conf.high)
  ) |>
  transmute(
    term,
    estimate = round(estimate, 3),
    `Std.Error` = round(std.error, 3),
    `Odds ratio` = round(odds_ratio, 2),
    `95% CI` = sprintf("[%.2f, %.2f]", or_low, or_high),
    p = signif(p.value, 3)
  )

knitr::kable(or_table)

```

```{r}
pred_prob_glmm <- predict(glmm_presence, type = "response")
obs <- log_reg_data$presence

roc_glmm <- roc(obs, pred_prob_glmm)
auc(roc_glmm) # Area under the curve: 0.8337- much better (for 1|channel_location/location)
#  # Area under the curve: 0.7597 for 1|channel_location

ranef(glmm_presence)$cond$location |>
  as.data.frame()

ranef(glmm_presence)$cond$channel_location |>
  as.data.frame()
# Large variation → occupancy differs strongly by site beyond measured habitat.


```

```{r echo=FALSE}
# confusion matrix 
pred_class <- ifelse(pred_prob > 0.5, 1, 0)
table(Predicted = pred_class, Observed = obs)
```

**Plots**

```{r}
re_loc <- broom.mixed::tidy(glmm_presence, effects = "ran_vals", conf.int = TRUE) |>
  filter(group == "location:channel_location") |>         
  rename(unit = level, re = estimate) |>
  mutate(
    odds_ratio = exp(re),
    or_low  = exp(conf.low),
    or_high = exp(conf.high)
  ) |> 
  arrange(odds_ratio) |>
  mutate(unit = factor(unit, levels = unit))

ggplot(re_loc, aes(x = odds_ratio, y = unit)) +
  geom_vline(xintercept = 1, linetype = 2, color = "gray50") +
  geom_point(size = 2) +
  geom_errorbarh(aes(xmin = or_low, xmax = or_high), height = 0.2) +
  labs(
    x = "Random-effect odds ratio (relative to global mean)",
    y = NULL,
    title = "Site / channel-unit effects on probability of presence"
  ) +
  scale_x_log10() +
  theme_minimal(base_size = 13)



```

```{r}

effects_df <- broom::tidy(glm_presence, conf.int = TRUE) |>
  filter(term != "(Intercept)") |>
  mutate(
    odds_ratio = exp(estimate),
    or_low = exp(conf.low),
    or_high = exp(conf.high),
    term = recode(term,
                  small_woody = "Small woody debris",
                  large_woody = "Large woody debris",
                  overhanging_veg = "Overhanging vegetation",
                  aquatic_veg = "Aquatic vegetation",
                  cobble_substrate = "Cobble substrate",
                  boulder_substrate = "Boulder substrate",
                  undercut_bank = "Undercut bank",
                  depth = "Depth",
                  velocity = "Velocity",
                  redd_total = "Total Number or Redds Nearby",
                  redd_presence = "Redds Nearby"
    )
  )

ggplot(effects_df, aes(x = odds_ratio, y = reorder(term, odds_ratio))) +
  geom_vline(xintercept = 1, linetype = 2, color = "gray50") +
  geom_point(size = 2.7) +
  geom_errorbarh(aes(xmin = or_low, xmax = or_high), height = 0.2) +
  scale_x_log10() +
  labs(
    x = "Odds ratio (log scale)",
    y = NULL,
    title = "Effect sizes for predictors of fish presence",
    caption = "points > 1 → higher probability of presence; 
    points < 1 → lower probability;  
    wider bars → greater uncertainty"
  ) +
  theme_minimal(base_size = 13)

```

### Logistic Regression with Random Effect Discussion

After controlling for local habitat characteristics, the probability of
fish occurrence remained significantly structured by site, with LFC
consistently supporting higher occupancy and HFC supporting lower
occupancy than expected.

Mixed-effects logistic models indicated strong spatial structuring of
occurrence beyond the effects of local habitat covariates.
Random-intercept estimates for channel units nested within locations
showed that some sites exhibited consistently higher baseline
probabilities of fish presence, whereas others were characterized by
lower occurrence than expected. For example, hatchery ditch (LFC) and
junkyard riffle (HFC) had markedly positive random effects (\~2–10×
higher odds of presence than the global mean), while eye side channel
(LFC) and weir riffle (LFC) showed substantially reduced occurrence
(≈60–70% lower odds). These patterns suggest the influence of additional
reach-scale or contextual factors not captured by measured microhabitat
variables, such as connectivity, geomorphic setting, or broader
hydraulic and thermal conditions.

After controlling for other habitat attributes, fish were most likely to
occur in units with riparian cover, undercut banks, woody structure, and
boulder features, all of which provide refuge and hydraulic complexity.
Depth and velocity played secondary roles, suggesting that microhabitat
structure is a stronger driver of occurrence than hydraulic conditions
alone. Some habitat types (e.g., cobble substrate, aquatic vegetation)
did not show clear relationships with presence once other covariates
were included.

```{r}
knitr::knit_exit()
```
